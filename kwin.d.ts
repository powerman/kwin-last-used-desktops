/**
 * Generated TypeScript definitions for KWin
 * Auto-generated from Doxygen documentation
 * Generated on: 2025-07-26T08:12:04.876Z
 * Classes parsed: 11
 *
 * Generated by: https://github.com/drendog/kwin-types-parser-ts
 */

// Signal type helper for KWin signals
interface Signal<T extends (...args: any[]) => void> {
    connect(callback: T): void;
    disconnect(callback: T): void;
}

// Qt Types - only types actually used in KWin interfaces
declare type QIcon = any;
declare type QPalette = any;
declare type QPoint = any;
declare type QPointF = any;
declare type QRect = any;
declare type QRectF = any;
declare type QRegion = any;
declare type QSize = any;
declare type QSizeF = any;
declare type QUuid = any;
declare type QVariant = any;
declare type QScriptValue = (...args: any[]) => void;

// Qt namespace types
declare namespace Qt {
    type Edge = any;
    const UserRole = 0x0100;
}

// std namespace types - only types actually used in KWin interfaces
declare namespace std {
    namespace chrono {
        type milliseconds = any;
    }
}
/** KWin namespace */
declare namespace KWin {
    // Global enums
    enum DeviceType {
        Desktop,
        Laptop,
        Phone,
        Touchpad,
        Touchscreen,
    }

    enum RenderingIntent {
        Perceptual,
        RelativeColorimetric,
        AbsoluteColorimetric,
        RelativeColorimetricWithBPC,
    }

    enum YUVMatrixCoefficients {
        Identity,
        BT601,
        BT709,
        BT2020,
    }

    enum EncodingRange {
        Limited,
        Full,
    }

    enum PointerButtonState {
        Released,
        Pressed,
    }

    enum PointerAxis {
        Vertical,
        Horizontal,
    }

    enum PointerAxisSource {
        Unknown,
        Wheel,
        Finger,
        Continuous,
        WheelTilt,
    }

    enum KeyboardKeyState {
        Released,
        Pressed,
        Repeated,
    }

    enum SwitchState {
        Off,
        On,
    }

    enum EffectFrameStyle {
        /** Displays no frame around the contents. */
        EffectFrameNone,
        /** Displays a basic box around the contents. */
        EffectFrameUnstyled,
        /** Displays a Plasma-styled frame around the contents. */
        EffectFrameStyled,
    }

    enum DataRole {
        WindowAddedGrabRole = 1,
        WindowClosedGrabRole,
        WindowMinimizedGrabRole,
        WindowUnminimizedGrabRole,
        /** For fullscreen effects to enforce blurring of windows,. */
        WindowForceBlurRole,
        /** For fullscreen effects to enforce the background contrast,. */
        WindowForceBackgroundContrastRole,
    }

    enum LoadEffectFlag {
        /** Effect should be loaded. */
        Load = 1 << 0,
        /** The Check Default Function needs to be invoked if the Effect provides it. */
        CheckDefaultFunction = 1 << 2,
    }

    enum CompositingType {
        NoCompositing = 0,
        /** Used as a flag whether OpenGL based compositing is used. The flag is or-ed to the enum values of the specific OpenGL types. The actual Compositors use the or OpenGLCompositing flags. If you need to know whether OpenGL is used, either and the flag or use EffectsHandler::isOpenGLCompositing(). */
        OpenGLCompositing = 1,
        QPainterCompositing = 1 << 2,
    }

    enum clientAreaOption {
        PlacementArea,
        MovementArea,
        MaximizeArea,
        MaximizeFullArea,
        FullScreenArea,
        WorkArea,
        FullArea,
        ScreenArea,
    }

    enum MaximizeMode {
        /** The window is not maximized in any direction. */
        MaximizeRestore = 0,
        /** The window is maximized vertically. */
        MaximizeVertical = 1,
        /** The window is maximized horizontally. */
        MaximizeHorizontal = 2,
        /** Equal to MaximizeVertical | MaximizeHorizontal. */
        MaximizeFull = MaximizeVertical | MaximizeHorizontal,
    }

    enum ElectricBorder {
        ElectricTop,
        ElectricTopRight,
        ElectricRight,
        ElectricBottomRight,
        ElectricBottom,
        ElectricBottomLeft,
        ElectricLeft,
        ElectricTopLeft,
        ELECTRIC_COUNT,
        ElectricNone,
    }

    enum ElectricBorderAction {
        ElectricActionNone,
        ElectricActionShowDesktop,
        ElectricActionLockScreen,
        ElectricActionKRunner,
        ElectricActionActivityManager,
        ElectricActionApplicationLauncher,
        ELECTRIC_ACTION_COUNT,
    }

    enum TabBoxMode {
        TabBoxWindowsMode,
        TabBoxWindowsAlternativeMode,
        TabBoxCurrentAppWindowsMode,
        TabBoxCurrentAppWindowsAlternativeMode,
    }

    enum KWinOption {
        CloseButtonCorner,
        SwitchDesktopOnScreenEdge,
        SwitchDesktopOnScreenEdgeMovingWindows,
    }

    enum PointerAxisDirection {
        PointerAxisUp,
        PointerAxisDown,
        PointerAxisLeft,
        PointerAxisRight,
    }

    enum SwipeDirection {
        Invalid,
        Down,
        Left,
        Up,
        Right,
    }

    enum PinchDirection {
        Expanding,
        Contracting,
    }

    enum SessionState {
        Normal,
        Saving,
        Quitting,
    }

    enum LED {
        NumLock = 1 << 0,
        CapsLock = 1 << 1,
        ScrollLock = 1 << 2,
        Compose = 1 << 3,
        Kana = 1 << 4,
    }

    enum Layer {
        UnknownLayer = -1,
        FirstLayer = 0,
        DesktopLayer = 0,
        BelowLayer,
        NormalLayer,
        AboveLayer,
        NotificationLayer,
        ActiveLayer,
        PopupLayer,
        CriticalNotificationLayer,
        OnScreenDisplayLayer,
        OverlayLayer,
        NumLayers,
    }

    enum QuickTileFlag {
        None = 0,
        Left = 1 << 0,
        Right = 1 << 1,
        Top = 1 << 2,
        Bottom = 1 << 3,
        Custom = 1 << 4,
        Horizontal = Left | Right,
        Vertical = Top | Bottom,
    }

    enum PresentationMode {
        VSync,
        AdaptiveSync,
        Async,
        AdaptiveAsync,
    }

    enum ContentType {
        None = 0,
        Photo = 1,
        Video = 2,
        Game = 3,
    }

    enum VrrPolicy {
        Never = 0,
        Always = 1,
        Automatic = 2,
    }

    enum PresentationModeHint {
        VSync,
        Async,
    }

    enum WindowType {
        /** intermediate value, do not use */
        Undefined = -2,
        /** indicates that the window did not define a window type. */
        Unknown = -1,
        /** indicates that this is a normal, top-level window */
        Normal = 0,
        /** indicates a desktop feature. This can include a single window containing desktop icons with the same dimensions as the screen, allowing the desktop environment to have full control of the desktop, without the need for proxying root window clicks. */
        Desktop = 1,
        /** indicates a dock or panel feature */
        Dock = 2,
        /** indicates a toolbar window */
        Toolbar = 3,
        /** indicates a pinnable (torn-off) menu window */
        Menu = 4,
        /** indicates that this is a dialog window */
        Dialog = 5,
        /** Deprecatedhas unclear meaning and is KDE-only */
        Override = 6,
        /** indicates a toplevel menu (AKA macmenu). This is a KDE extension to the _NET_WM_WINDOW_TYPE mechanism. */
        TopMenu = 7,
        /** indicates a utility window */
        Utility = 8,
        /** indicates that this window is a splash screen window. */
        Splash = 9,
        /** indicates a dropdown menu (from a menubar typically) */
        DropdownMenu = 10,
        /** indicates a popup menu (a context menu typically) */
        PopupMenu = 11,
        /** indicates a tooltip window */
        Tooltip = 12,
        /** indicates a notification window */
        Notification = 13,
        /** indicates that the window is a list for a combobox */
        ComboBox = 14,
        /** indicates a window that represents the dragged object during DND operation */
        DNDIcon = 15,
        /** indicates an On Screen Display window (such as volume feedback) */
        OnScreenDisplay = 16,
        /** indicates a critical notification (such as battery is running out) */
        CriticalNotification = 17,
        /** indicates that this window is an applet. */
        AppletPopup = 18,
    }

    enum WindowTypeMask {
        /** See alsoNormal */
        NormalMask = 1 << 0,
        /** See alsoDesktop */
        DesktopMask = 1 << 1,
        /** See alsoDock */
        DockMask = 1 << 2,
        /** See alsoToolbar */
        ToolbarMask = 1 << 3,
        /** See alsoMenu */
        MenuMask = 1 << 4,
        /** See alsoDialog */
        DialogMask = 1 << 5,
        /** See alsoOverride */
        OverrideMask = 1 << 6,
        /** See alsoTopMenu */
        TopMenuMask = 1 << 7,
        /** See alsoUtility */
        UtilityMask = 1 << 8,
        /** See alsoSplash */
        SplashMask = 1 << 9,
        /** See alsoDropdownMenu */
        DropdownMenuMask = 1 << 10,
        /** See alsoPopupMenu */
        PopupMenuMask = 1 << 11,
        /** See alsoTooltip */
        TooltipMask = 1 << 12,
        /** See alsoNotification */
        NotificationMask = 1 << 13,
        /** See alsoComboBox */
        ComboBoxMask = 1 << 14,
        /** See alsoDNDIcon */
        DNDIconMask = 1 << 15,
        /** NON STANDARD. */
        OnScreenDisplayMask = 1 << 16,
        /** NON STANDARD. */
        CriticalNotificationMask = 1 << 17,
        /** NON STANDARD. */
        AppletPopupMask = 1 << 18,
        /** All window types. */
        AllTypesMask = 0xffffffff,
    }

    enum OutputConfigurationError {
        None,
        Unknown,
        TooManyEnabledOutputs,
    }

    enum Driver {
        Driver_R100,
        Driver_R200,
        Driver_R300C,
        Driver_R300G,
        Driver_R600C,
        Driver_R600G,
        Driver_Nouveau,
        Driver_Intel,
        Driver_NVidia,
        Driver_Catalyst,
        Driver_Swrast,
        Driver_Softpipe,
        Driver_Llvmpipe,
        Driver_VirtualBox,
        Driver_VMware,
        Driver_Qualcomm,
        Driver_RadeonSI,
        Driver_Virgl,
        Driver_Panfrost,
        Driver_Lima,
        Driver_VC4,
        Driver_V3D,
        Driver_Unknown,
    }

    enum ChipClass {
        R100 = 0,
        R200,
        R300,
        R400,
        R500,
        R600,
        R700,
        Evergreen,
        NorthernIslands,
        SouthernIslands,
        SeaIslands,
        VolcanicIslands,
        ArcticIslands,
        Vega,
        Navi,
        UnknownRadeon = 999,
        NV10 = 1000,
        NV20,
        NV30,
        NV40,
        G80,
        GF100,
        UnknownNVidia = 1999,
        I8XX = 2000,
        I915,
        I965,
        SandyBridge,
        IvyBridge,
        Haswell,
        BayTrail,
        Cherryview,
        Broadwell,
        ApolloLake,
        Skylake,
        GeminiLake,
        KabyLake,
        CoffeeLake,
        WhiskeyLake,
        CometLake,
        CannonLake,
        IceLake,
        TigerLake,
        UnknownIntel = 2999,
        Adreno1XX = 3000,
        Adreno2XX,
        Adreno3XX,
        Adreno4XX,
        Adreno5XX,
        UnknownAdreno = 3999,
        MaliT7XX = 4000,
        MaliT8XX,
        MaliGXX,
        UnknownPanfrost = 4999,
        Mali400 = 5000,
        Mali450,
        Mali470,
        UnknownLima = 5999,
        VC4_2_1 = 6000,
        UnknownVideoCore4 = 6999,
        V3D_4_2 = 7000,
        UnknownVideoCore3D = 7999,
        UnknownChipClass = 99999,
    }

    enum ShaderTrait {
        MapTexture = 1 << 0,
        UniformColor = 1 << 1,
        Modulate = 1 << 2,
        AdjustSaturation = 1 << 3,
        TransformColorspace = 1 << 4,
        MapExternalTexture = 1 << 5,
        MapYUVTexture = 1 << 6,
        RoundedCorners = 1 << 7,
        Border = 1 << 8,
    }

    enum TextureCoordinateType {
        NormalizedCoordinates = 0,
        UnnormalizedCoordinates,
    }

    enum VertexAttributeType {
        VA_Position = 0,
        VA_TexCoord = 1,
        VertexAttributeCount = 2,
    }

    enum XwaylandEavesdropsMode {
        None,
        NonCharacterKeys,
        AllKeysWithModifier,
        All,
    }

    enum XwaylandCrashPolicy {
        Stop,
        Restart,
    }

    enum PlacementPolicy {
        PlacementNone,
        PlacementDefault,
        PlacementUnknown,
        PlacementRandom,
        PlacementSmart,
        PlacementCentered,
        PlacementZeroCornered,
        PlacementUnderMouse,
        PlacementOnMainWindow,
        PlacementMaximizing,
    }

    enum NightLightMode {
        /** Color temperature is constant thoughout the day. */
        Constant,
        /** The color temperature is adjusted based on time of day. */
        DarkLight,
    }

    enum ScreenShotFlag {
        /** Include window titlebar and borders. */
        ScreenShotIncludeDecoration = 0x1,
        /** Include the cursor. */
        ScreenShotIncludeCursor = 0x2,
        /** Take the screenshot at the native resolution. */
        ScreenShotNativeResolution = 0x4,
        /** Include the window shadow. */
        ScreenShotIncludeShadow = 0x8,
    }

    enum StrutArea {
        StrutAreaInvalid = 0,
        StrutAreaTop = 1 << 0,
        StrutAreaRight = 1 << 1,
        StrutAreaBottom = 1 << 2,
        StrutAreaLeft = 1 << 3,
        StrutAreaAll = StrutAreaTop | StrutAreaRight | StrutAreaBottom | StrutAreaLeft,
    }

    enum TextInputContentHint {
        /** no special behaviour */
        None = 0,
        /** suggest word completions */
        AutoCompletion = 1 << 0,
        /** suggest word corrections */
        AutoCorrection = 1 << 1,
        /** switch to uppercase letters at the start of a sentence */
        AutoCapitalization = 1 << 2,
        /** prefer lowercase letters */
        LowerCase = 1 << 3,
        /** prefer uppercase letters */
        UpperCase = 1 << 4,
        /** prefer casing for titles and headings (can be language dependent) */
        TitleCase = 1 << 5,
        /** characters should be hidden */
        HiddenText = 1 << 6,
        /** typed text should not be stored */
        SensitiveData = 1 << 7,
        /** just latin characters should be entered */
        Latin = 1 << 8,
        /** the text input is multi line */
        MultiLine = 1 << 9,
    }

    enum TextInputContentPurpose {
        /** default input, allowing all characters */
        Normal,
        /** allow only alphabetic characters */
        Alpha,
        /** allow only digits */
        Digits,
        /** input a number (including decimal separator and sign) */
        Number,
        /** input a phone number */
        Phone,
        /** input an URL */
        Url,
        /** input an email address */
        Email,
        /** input a name of a person */
        Name,
        /** input a password */
        Password,
        /** input a date */
        Date,
        /** input a time */
        Time,
        /** input a date and time */
        DateTime,
        /** input for a terminal */
        Terminal,
        /** input is numeric password */
        Pin,
    }

    enum TextInputChangeCause {
        /** Change caused by input method */
        InputMethod,
        /** Something else other than input method caused change */
        Other,
    }

    enum WaylandGeometryType {
        WaylandGeometryClient = 0x1,
        WaylandGeometryFrame = 0x2,
        WaylandGeometryBuffer = 0x4,
    }

    namespace WorkspaceWrapper {
        enum ClientAreaOption {
            /** geometry where a window will be initially placed after being mapped window movement snapping area? ignore struts */
            PlacementArea,
            /** geometry to which a window will be maximized */
            MovementArea,
            /** like MaximizeArea, but ignore struts - used e.g. for topmenu */
            MaximizeArea,
            /** area for fullscreen windows */
            MaximizeFullArea,
            /** whole workarea (all screens together) */
            FullScreenArea,
            /** whole area (all screens together), ignore struts */
            WorkArea,
            /** one whole screen, ignore struts */
            FullArea,
            ScreenArea,
        }

        enum ElectricBorder {
            ElectricTop,
            ElectricTopRight,
            ElectricRight,
            ElectricBottomRight,
            ElectricBottom,
            ElectricBottomLeft,
            ElectricLeft,
            ElectricTopLeft,
            ELECTRIC_COUNT,
            ElectricNone,
        }
    }

    namespace Output {
        enum DpmsMode {
            On,
            Standby,
            Suspend,
            Off,
            AboutToTurnOff,
        }

        enum Capability {
            Dpms = 1,
            Overscan = 1 << 1,
            Vrr = 1 << 2,
            RgbRange = 1 << 3,
            HighDynamicRange = 1 << 4,
            WideColorGamut = 1 << 5,
            AutoRotation = 1 << 6,
            IccProfile = 1 << 7,
            Tearing = 1 << 8,
            BrightnessControl = 1 << 9,
            BuiltInColorProfile = 1 << 10,
            DdcCi = 1 << 11,
            MaxBitsPerColor = 1 << 12,
            Edr = 1 << 13,
        }

        enum SubPixel {
            Unknown,
            None,
            Horizontal_RGB,
            Horizontal_BGR,
            Vertical_RGB,
            Vertical_BGR,
        }

        enum RgbRange {
            Automatic = 0,
            Full = 1,
            Limited = 2,
        }

        enum AutoRotationPolicy {
            Never = 0,
            InTabletMode,
            Always,
        }

        enum ColorProfileSource {
            sRGB = 0,
            ICC,
            EDID,
        }

        enum ColorPowerTradeoff {
            PreferEfficiency = 0,
            PreferAccuracy,
        }

        enum EdrPolicy {
            Never = 0,
            Always,
        }
    }

    namespace Tile {
        enum LayoutDirection {
            Floating = 0,
            Horizontal = 1,
            Vertical = 2,
        }
    }

    namespace Window {
        enum SizeMode {
            SizeModeAny,
            /** Try not to affect width. */
            SizeModeFixedW,
            /** Try not to affect height. */
            SizeModeFixedH,
            /** Try not to make it larger in either direction. */
            SizeModeMax,
        }

        enum SameApplicationCheck {
            RelaxedForActive = 1 << 0,
            AllowCrossProcesses = 1 << 1,
        }

        enum MoveResizeMode {
            None,
            Move = 0x1,
            Resize = 0x2,
            MoveResize = Move | Resize,
        }
    }

    namespace CustomTile {
        enum LayoutDirection {
            Floating = 0,
            Horizontal = 1,
            Vertical = 2,
        }
    }

    namespace TileModel {
        enum Roles {
            TileRole = Qt.UserRole + 1,
        }
    }

    namespace Options {
        enum FocusPolicy {
            /** Clicking into a window activates it. This is also the default. */
            ClickToFocus,
            /** Moving the mouse pointer actively onto a normal window activates it. For convenience, the desktop and windows on the dock are excluded. They require clicking. */
            FocusFollowsMouse,
            /** The window that happens to be under the mouse pointer becomes active. The invariant is: no window can have focus that is not under the mouse. This also means that Alt-Tab won&#x27;t work properly and popup dialogs are usually unsable with the keyboard. Note that the desktop and windows on the dock are excluded for convenience. They get focus only when clicking on it. */
            FocusUnderMouse,
            /** This is even worse than FocusUnderMouse. Only the window under the mouse pointer is active. If the mouse points nowhere, nothing has the focus. If the mouse points onto the desktop, the desktop has focus. The same holds for windows on the dock. */
            FocusStrictlyUnderMouse,
        }

        enum ActivationDesktopPolicy {
            SwitchToOtherDesktop,
            BringToCurrentDesktop,
            DoNothing,
        }

        enum WindowOperation {
            MaximizeOp = 5000,
            RestoreOp,
            MinimizeOp,
            MoveOp,
            UnrestrictedMoveOp,
            ResizeOp,
            UnrestrictedResizeOp,
            CloseOp,
            OnAllDesktopsOp,
            KeepAboveOp,
            KeepBelowOp,
            WindowRulesOp,
            /** @obsolete */
            ToggleStoreSettingsOp = 5011,
            HMaximizeOp,
            VMaximizeOp,
            LowerOp,
            FullScreenOp,
            NoBorderOp,
            NoOp,
            SetupWindowShortcutOp,
            ApplicationRulesOp,
        }

        enum MouseCommand {
            MouseRaise,
            MouseLower,
            MouseOperationsMenu,
            MouseToggleRaiseAndLower,
            MouseActivateAndRaise,
            MouseActivateAndLower,
            MouseActivate,
            MouseActivateRaiseAndPassClick,
            MouseActivateAndPassClick,
            MouseMove,
            MouseUnrestrictedMove,
            MouseActivateRaiseAndMove,
            MouseActivateRaiseAndUnrestrictedMove,
            MouseResize,
            MouseUnrestrictedResize,
            MouseMaximize,
            MouseRestore,
            MouseMinimize,
            MouseNextDesktop,
            MousePreviousDesktop,
            MouseAbove,
            MouseBelow,
            MouseOpacityMore,
            MouseOpacityLess,
            MouseClose,
            MouseNothing,
            MouseActivateRaiseOnReleaseAndPassClick,
        }

        enum MouseWheelCommand {
            MouseWheelRaiseLower,
            MouseWheelMaximizeRestore,
            MouseWheelAboveBelow,
            MouseWheelPreviousNextDesktop,
            MouseWheelChangeOpacity,
            MouseWheelNothing,
        }
    }

    class WorkspaceWrapper {
        /** Properties */
        readonly desktops: KWin.VirtualDesktop[];

        currentDesktop: KWin.VirtualDesktop;

        activeWindow: KWin.Window;

        readonly desktopGridSize: QSize;

        readonly desktopGridWidth: number;

        desktopGridHeight: number;

        readonly workspaceWidth: number;

        readonly workspaceHeight: number;

        readonly workspaceSize: QSize;

        readonly activeScreen: KWin.Output;

        readonly screens: KWin.Output[];

        readonly screenOrder: KWin.Output[];

        currentActivity: string;

        readonly activities: string[];

        /** The bounding size of all screens combined. Overlapping areas are not counted multiple times. */
        readonly virtualScreenSize: QSize;

        /** The bounding geometry of all screens combined. Always starts at (0,0) and has virtualScreenSize as it&#x27;s size. */
        readonly virtualScreenGeometry: QRect;

        /** List of Clients currently managed by KWin, ordered by their visibility (later ones cover earlier ones). */
        readonly stackingOrder: KWin.Window[];

        /** The current position of the cursor. */
        readonly cursorPos: QPoint;

        constructor();

        /** Qt Decorated Methods */
        /** @Q_INVOKABLE  */
        screenAt(pos: QPointF): KWin.Output;
        /** @Q_INVOKABLE  */
        tilingForScreen(screenName: string): KWin.TileManager;
        /** @Q_INVOKABLE  */
        tilingForScreen(output: KWin.Output): KWin.TileManager;
        /**
         * Returns the root tile for the given output and desktop.
         * @Q_INVOKABLE
         */
        rootTile(output: KWin.Output, desktop: KWin.VirtualDesktop): KWin.Tile;
        /**
         * Returns the geometry a Client can use with the specified option. This method should be preferred over other methods providing screen sizes as the various options take constraints such as struts set on panels into account. This method is also multi screen aware, but there are also options to get full areas.
         * @Q_SCRIPTABLE
         */
        clientArea(
            option: KWin.WorkspaceWrapper.ClientAreaOption,
            output: KWin.Output,
            desktop: KWin.VirtualDesktop,
        ): QRectF;
        /**
         * Overloaded method for convenience.
         * @Q_SCRIPTABLE
         */
        clientArea(option: KWin.WorkspaceWrapper.ClientAreaOption, client: KWin.Window): QRectF;
        /** @Q_SCRIPTABLE  */
        clientArea(option: KWin.WorkspaceWrapper.ClientAreaOption, client: KWin.Window): QRectF;
        /**
         * Create a new virtual desktop at the requested position.
         * @Q_SCRIPTABLE
         */
        createDesktop(position: number, name: string): void;
        /**
         * Removes the specified virtual desktop.
         * @Q_SCRIPTABLE
         */
        removeDesktop(desktop: KWin.VirtualDesktop): void;
        /**
         * Moves the desktop to the specified position.
         * @Q_SCRIPTABLE
         */
        moveDesktop(desktop: KWin.VirtualDesktop, position: number): void;
        /**
         * Provides support information about the currently running KWin instance.
         * @Q_SCRIPTABLE
         */
        supportInformation(): string;
        /**
         * Raises a Window above all others on the screen.
         * @Q_INVOKABLE
         */
        raiseWindow(window: KWin.Window): void;
        /**
         * Finds up to count windows at a particular location, prioritizing the topmost one first. A negative count returns all matching clients.
         * @Q_INVOKABLE
         */
        windowAt(pos: QPointF, count?: number): KWin.Window[];
        /**
         * Checks if a specific effect is currently active.
         * @Q_INVOKABLE
         */
        isEffectActive(pluginId: string): boolean;
        /**
         * Defines that a window needs to remain under another
         * @Q_INVOKABLE
         */
        constrain(below: KWin.Window, above: KWin.Window): void;
        /**
         * Breaks the constraint where a window is to remain under another
         * @Q_INVOKABLE
         */
        unconstrain(below: KWin.Window, above: KWin.Window): void;

        /** Signals */
        windowAdded: Signal<(window: KWin.Window) => void>;
        windowRemoved: Signal<(window: KWin.Window) => void>;
        windowActivated: Signal<(window: KWin.Window) => void>;
        /** This signal is emitted when a virtual desktop is added or removed. */
        desktopsChanged: Signal<() => void>;
        /** Signal emitted whenever the layout of virtual desktops changed. That is desktopGrid(Size/Width/Height) will have new values. */
        desktopLayoutChanged: Signal<() => void>;
        /** Emitted when the output list changes, e.g. an output is connected or removed. */
        screensChanged: Signal<() => void>;
        /** Emitted when the output order list changes, e.g. the primary output changes. */
        screenOrderChanged: Signal<() => void>;
        /** Signal emitted whenever the current activity changed. */
        currentActivityChanged: Signal<(id: string) => void>;
        /** Signal emitted whenever the list of activities changed. */
        activitiesChanged: Signal<(id: string) => void>;
        /** This signal is emitted when a new activity is added */
        activityAdded: Signal<(id: string) => void>;
        /** This signal is emitted when the activity is removed */
        activityRemoved: Signal<(id: string) => void>;
        /** Emitted whenever the virtualScreenSize changes. */
        virtualScreenSizeChanged: Signal<() => void>;
        /** Emitted whenever the virtualScreenGeometry changes. */
        virtualScreenGeometryChanged: Signal<() => void>;
        /** This signal is emitted when the current virtual desktop changes. */
        currentDesktopChanged: Signal<(previous: KWin.VirtualDesktop) => void>;
        /** This signal is emitted when the cursor position changes. */
        cursorPosChanged: Signal<() => void>;
    }

    class VirtualDesktop {
        /** Properties */
        readonly id: string;

        readonly x11DesktopNumber: number;

        name: string;

        constructor();

        /** Signals */
        nameChanged: Signal<() => void>;
        x11DesktopNumberChanged: Signal<() => void>;
        /** Emitted just before the desktop gets destroyed. */
        aboutToBeDestroyed: Signal<() => void>;
    }

    class Output {
        /** Properties */
        readonly geometry: QRect;

        readonly devicePixelRatio: number;

        readonly name: string;

        readonly manufacturer: string;

        readonly model: string;

        readonly serialNumber: string;

        constructor();

        /** Qt Decorated Methods */
        /** @Q_INVOKABLE  */
        mapToGlobal(pos: QPointF): QPointF;
        /** @Q_INVOKABLE  */
        mapFromGlobal(pos: QPointF): QPointF;

        /** Signals */
        /** This signal is emitted when the geometry of this output has changed. */
        geometryChanged: Signal<() => void>;
        /** This signal is emitted when the output has been enabled or disabled. */
        enabledChanged: Signal<() => void>;
        /** This signal is emitted when the device pixel ratio of the output has changed. */
        scaleChanged: Signal<() => void>;
        /** Notifies that the display will be dimmed in time ms. This allows effects to plan for it and hopefully animate it */
        aboutToTurnOff: Signal<(time: std.chrono.milliseconds) => void>;
        /** Notifies that the output has been turned on and the wake can be decorated. */
        wakeUp: Signal<() => void>;
        /** Notifies that the output is about to change configuration based on a user interaction.
Be it because it gets a transformation or moved around.
Only to be used for effects */
        aboutToChange: Signal<(changeSet: OutputChangeSet) => void>;
        /** Notifies that the output changed based on a user interaction.
Be it because it gets a transformation or moved around.
Only to be used for effects */
        changed: Signal<() => void>;
        currentModeChanged: Signal<() => void>;
        modesChanged: Signal<() => void>;
        outputChange: Signal<(damagedRegion: QRegion) => void>;
        transformChanged: Signal<() => void>;
        dpmsModeChanged: Signal<() => void>;
        capabilitiesChanged: Signal<() => void>;
        overscanChanged: Signal<() => void>;
        vrrPolicyChanged: Signal<() => void>;
        rgbRangeChanged: Signal<() => void>;
        wideColorGamutChanged: Signal<() => void>;
        referenceLuminanceChanged: Signal<() => void>;
        highDynamicRangeChanged: Signal<() => void>;
        autoRotationPolicyChanged: Signal<() => void>;
        iccProfileChanged: Signal<() => void>;
        iccProfilePathChanged: Signal<() => void>;
        brightnessMetadataChanged: Signal<() => void>;
        sdrGamutWidenessChanged: Signal<() => void>;
        colorDescriptionChanged: Signal<() => void>;
        blendingColorChanged: Signal<() => void>;
        colorProfileSourceChanged: Signal<() => void>;
        brightnessChanged: Signal<() => void>;
        colorPowerTradeoffChanged: Signal<() => void>;
        dimmingChanged: Signal<() => void>;
        uuidChanged: Signal<() => void>;
        replicationSourceChanged: Signal<() => void>;
        allowDdcCiChanged: Signal<() => void>;
        maxBitsPerColorChanged: Signal<() => void>;
        edrPolicyChanged: Signal<() => void>;
    }

    class TileManager {
        /** Properties */
        readonly rootTile: KWin.Tile;

        readonly model: TileModel;

        constructor();

        /** Qt Decorated Methods */
        /** @Q_INVOKABLE  */
        bestTileForPosition(x: number, y: number): KWin.Tile;

        /** Signals */
        tileRemoved: Signal<(tile: KWin.Tile) => void>;
        rootTileChanged: Signal<(rootTile: CustomTile) => void>;
        modelChanged: Signal<(model: TileModel) => void>;
    }

    class Tile {
        /** Properties */
        relativeGeometry: QRectF;

        readonly absoluteGeometry: QRectF;

        readonly absoluteGeometryInScreen: QRectF;

        padding: number;

        minimumSize: QSizeF;

        readonly positionInLayout: number;

        readonly parent: Tile;

        readonly tiles: KWin.Tile[];

        readonly windows: KWin.Window[];

        readonly isLayout: boolean;

        readonly canBeRemoved: boolean;

        constructor();

        /** Qt Decorated Methods */
        /** @Q_INVOKABLE  */
        resizeByPixels(delta: number, edge: Qt.Edge): void;
        /** @Q_INVOKABLE  */
        manage(window: Window): boolean;
        /** @Q_INVOKABLE  */
        unmanage(window: Window): boolean;

        /** Signals */
        activeChanged: Signal<(active: boolean) => void>;
        relativeGeometryChanged: Signal<() => void>;
        absoluteGeometryChanged: Signal<() => void>;
        windowGeometryChanged: Signal<() => void>;
        paddingChanged: Signal<(padding: number) => void>;
        minimumSizeChanged: Signal<(size: QSizeF) => void>;
        rowChanged: Signal<(row: number) => void>;
        isLayoutChanged: Signal<(isLayout: boolean) => void>;
        childTilesChanged: Signal<() => void>;
        windowAdded: Signal<(window: Window) => void>;
        windowRemoved: Signal<(window: Window) => void>;
        windowsChanged: Signal<() => void>;
    }

    class Window {
        /** Properties */
        /** This property holds the rectangle that the pixmap or buffer of this Window occupies on the screen. This rectangle includes invisible portions of the window, e.g. client-side drop shadows, etc. */
        readonly bufferGeometry: QRectF;

        /** The geometry of the Window without frame borders. */
        readonly clientGeometry: QRectF;

        /** This property holds the position of the Window&#x27;s frame geometry. */
        readonly pos: QPointF;

        /** This property holds the size of the Window&#x27;s frame geometry. */
        readonly size: QSizeF;

        /** This property holds the x position of the Window&#x27;s frame geometry. */
        readonly x: number;

        /** This property holds the y position of the Window&#x27;s frame geometry. */
        readonly y: number;

        /** This property holds the width of the Window&#x27;s frame geometry. */
        readonly width: number;

        /** This property holds the height of the Window&#x27;s frame geometry. */
        readonly height: number;

        opacity: number;

        /** The output where the window center is on */
        readonly output: KWin.Output;

        readonly rect: QRectF;

        readonly resourceName: string;

        readonly resourceClass: string;

        readonly windowRole: string;

        /** Returns whether the window is a desktop background window (the one with wallpaper). See _NET_WM_WINDOW_TYPE_DESKTOP at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly desktopWindow: boolean;

        /** Returns whether the window is a dock (i.e. a panel). See _NET_WM_WINDOW_TYPE_DOCK at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly dock: boolean;

        /** Returns whether the window is a standalone (detached) toolbar window. See _NET_WM_WINDOW_TYPE_TOOLBAR at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly toolbar: boolean;

        /** Returns whether the window is a torn-off menu. See _NET_WM_WINDOW_TYPE_MENU at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly menu: boolean;

        /** Returns whether the window is a &quot;normal&quot; window, i.e. an application or any other window for which none of the specialized window types fit. See _NET_WM_WINDOW_TYPE_NORMAL at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly normalWindow: boolean;

        /** Returns whether the window is a dialog window. See _NET_WM_WINDOW_TYPE_DIALOG at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly dialog: boolean;

        /** Returns whether the window is a splashscreen. Note that many (especially older) applications do not support marking their splash windows with this type. See _NET_WM_WINDOW_TYPE_SPLASH at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly splash: boolean;

        /** Returns whether the window is a utility window, such as a tool window. See _NET_WM_WINDOW_TYPE_UTILITY at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly utility: boolean;

        /** Returns whether the window is a dropdown menu (i.e. a popup directly or indirectly open from the application&#x27;s menubar). See _NET_WM_WINDOW_TYPE_DROPDOWN_MENU at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly dropdownMenu: boolean;

        /** Returns whether the window is a popup menu (that is not a torn-off or dropdown menu). See _NET_WM_WINDOW_TYPE_POPUP_MENU at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly popupMenu: boolean;

        /** Returns whether the window is a tooltip. See _NET_WM_WINDOW_TYPE_TOOLTIP at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly tooltip: boolean;

        /** Returns whether the window is a window with a notification. See _NET_WM_WINDOW_TYPE_NOTIFICATION at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly notification: boolean;

        /** Returns whether the window is a window with a critical notification. */
        readonly criticalNotification: boolean;

        /** Returns whether the window is an applet popup. */
        readonly appletPopup: boolean;

        /** Returns whether the window is an On Screen Display. */
        readonly onScreenDisplay: boolean;

        /** Returns whether the window is a combobox popup. See _NET_WM_WINDOW_TYPE_COMBO at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly comboBox: boolean;

        /** Returns whether the window is a Drag&amp;Drop icon. See _NET_WM_WINDOW_TYPE_DND at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly dndIcon: boolean;

        /** Returns the NETWM window type. See https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . */
        readonly windowType: WindowType;

        /** Whether this Window is managed by KWin (it has control over its placement and other aspects, as opposed to override-redirect windows that are entirely handled by the application). */
        readonly managed: boolean;

        /** Whether this Window represents an already deleted window and only kept for the compositor for animations. */
        readonly deleted: boolean;

        /** Whether the window does not want to be animated on window close. There are legit reasons for this like a screenshot application which does not want its window being captured. */
        skipsCloseAnimation: boolean;

        /** Whether the window is a popup. */
        readonly popupWindow: boolean;

        /** Whether this Window represents the outline. */
        readonly outline: boolean;

        /** This property holds a UUID to uniquely identify this Window. */
        readonly internalId: QUuid;

        /** The pid of the process owning this window. */
        readonly pid: number;

        /** The position of this window within Workspace&#x27;s window stack. */
        readonly stackingOrder: number;

        /** Whether this Window is fullScreen. A Window might either be fullScreen due to the _NET_WM property or through a legacy support hack. The fullScreen state can only be changed if the Window does not use the legacy hack. To be sure whether the state changed, connect to the notify signal. */
        fullScreen: boolean;

        /** Whether the Window can be set to fullScreen. The property is evaluated each time it is invoked. Because of that there is no notify signal. */
        readonly fullScreenable: boolean;

        /** Whether this Window is active or not. Use Workspace::activateWindow() to activate a Window. */
        readonly active: boolean;

        /** The virtual desktops this client is on. If it&#x27;s on all desktops, the list is empty. */
        desktops: KWin.VirtualDesktop[];

        /** Whether the Window is on all desktops. That is desktop is -1. */
        onAllDesktops: boolean;

        /** The activities this client is on. If it&#x27;s on all activities the property is empty. */
        activities: string[];

        /** Indicates that the window should not be included on a taskbar. */
        skipTaskbar: boolean;

        /** Indicates that the window should not be included on a Pager. */
        skipPager: boolean;

        /** Whether the Window should be excluded from window switching effects. */
        skipSwitcher: boolean;

        /** Whether the window can be closed by the user. */
        readonly closeable: boolean;

        readonly icon: QIcon;

        /** Whether the Window is set to be kept above other windows. */
        keepAbove: boolean;

        /** Whether the Window is set to be kept below other windows. */
        keepBelow: boolean;

        /** Whether the Window can be minimized. The property is evaluated each time it is invoked. Because of that there is no notify signal. */
        readonly minimizable: boolean;

        /** Whether the Window is minimized. */
        minimized: boolean;

        /** The optional geometry representing the minimized Window in e.g a taskbar. See _NET_WM_ICON_GEOMETRY at https://standards.freedesktop.org/wm-spec/wm-spec-latest.html . The value is evaluated each time the getter is called. Because of that no changed signal is provided. */
        readonly iconGeometry: QRectF;

        /** Returns whether the window is any of special windows types (desktop, dock, splash, ...), i.e. window types that usually don&#x27;t have a window frame and the user does not use window management (moving, raising,...) on them. The value is evaluated each time the getter is called. Because of that no changed signal is provided. */
        readonly specialWindow: boolean;

        /** Whether window state _NET_WM_STATE_DEMANDS_ATTENTION is set. This state indicates that some action in or with the window happened. For example, it may be set by the Window Manager if the window requested activation but the Window Manager refused it, or the application may set it if it finished some work. This state may be set by both the Window and the Window Manager. It should be unset by the Window Manager when it decides the window got the required attention (usually, that it got activated). */
        demandsAttention: boolean;

        /** The Caption of the Window. Read from WM_NAME property together with a suffix for hostname and shortcut. To read only the caption as provided by WM_NAME, use captionNormal. */
        readonly caption: string;

        /** The Caption of the Window. Read from WM_NAME property. */
        readonly captionNormal: string;

        /** Minimum size as specified in WM_NORMAL_HINTS */
        readonly minSize: QSizeF;

        /** Maximum size as specified in WM_NORMAL_HINTS */
        readonly maxSize: QSizeF;

        /** Whether the Window can accept keyboard focus. The value is evaluated each time the getter is called. Because of that no changed signal is provided. */
        readonly wantsInput: boolean;

        /** Whether the Window is a transient Window to another Window. */
        readonly transient: boolean;

        /** The Window to which this Window is a transient if any. */
        readonly transientFor: KWin.Window;

        /** Whether the Window represents a modal window. */
        readonly modal: boolean;

        /** The geometry of this Window. Be aware that depending on resize mode the frameGeometryChanged signal might be emitted at each resize step or only at the end of the resize operation. */
        frameGeometry: QRectF;

        /** Whether the Window is currently being moved by the user. Notify signal is emitted when the Window starts or ends move/resize mode. */
        readonly move: boolean;

        /** Whether the Window is currently being resized by the user. Notify signal is emitted when the Window starts or ends move/resize mode. */
        readonly resize: boolean;

        /** Whether the decoration is currently using an alpha channel. */
        readonly decorationHasAlpha: boolean;

        /** Whether the window has a decoration or not. This property is not allowed to be set by applications themselves. The decision whether a window has a border or not belongs to the window manager. If this property gets abused by application developers, it will be removed again. */
        noBorder: boolean;

        /** Whether the Window provides context help. Mostly needed by decorations to decide whether to show the help button or not. */
        readonly providesContextHelp: boolean;

        /** Whether the Window can be maximized both horizontally and vertically. The property is evaluated each time it is invoked. Because of that there is no notify signal. */
        readonly maximizable: boolean;

        /** Whether the window is maximized horizontally, vertically or fully. This is read only, in order to maximize from a script use the setMaximize function */
        readonly maximizeMode: KWin.MaximizeMode;

        /** Whether the Window is moveable. Even if it is not moveable, it might be possible to move it to another screen. The property is evaluated each time it is invoked. Because of that there is no notify signal. */
        readonly moveable: boolean;

        /** Whether the Window can be moved to another screen. The property is evaluated each time it is invoked. Because of that there is no notify signal. */
        readonly moveableAcrossScreens: boolean;

        /** Whether the Window can be resized. The property is evaluated each time it is invoked. Because of that there is no notify signal. */
        readonly resizeable: boolean;

        /** The desktop file name of the application this Window belongs to.
This is either the base name without full path and without file extension of the desktop file for the window&#x27;s application (e.g. &quot;org.kde.foo&quot;).
The application&#x27;s desktop file name can also be the full path to the desktop file (e.g. &quot;/opt/kde/share/org.kde.foo.desktop&quot;) in case it&#x27;s not in a standard location. */
        readonly desktopFileName: string;

        /** Whether an application menu is available for this Window */
        readonly hasApplicationMenu: boolean;

        /** Whether the application menu for this Window is currently opened */
        readonly applicationMenuActive: boolean;

        /** Whether this window is unresponsive.
When an application failed to react on a ping request in time, it is considered unresponsive. This usually indicates that the application froze or crashed. */
        readonly unresponsive: boolean;

        /** The color scheme set on this window Absolute file path, or name of palette in the user&#x27;s config directory following KColorSchemes format. An empty string indicates the default palette from kdeglobals is used. */
        readonly colorScheme: string;

        readonly layer: KWin.Layer;

        /** Whether this window is hidden. It&#x27;s usually the case with auto-hide panels. */
        readonly hidden: boolean;

        /** The Tile this window is associated to, if any */
        tile: KWin.Tile;

        /** Returns whether this window is an input method window. This is only used for Wayland. */
        readonly inputMethod: boolean;

        /** A client-provided tag of the window. Not necessarily unique, but can be used to identify similar windows across application restarts */
        readonly tag: string;

        /** A client-provided description of the window */
        readonly description: string;

        constructor();

        /** Qt Decorated Methods */
        /**
         * Sets the maximization according to vertically and horizontally.
         * @Q_INVOKABLE
         */
        setMaximize(vertically: boolean, horizontally: boolean, restore?: QRectF): void;

        /** Signals */
        stackingOrderChanged: Signal<() => void>;
        opacityChanged: Signal<(window: KWin.Window, oldOpacity: number) => void>;
        damaged: Signal<(window: KWin.Window) => void>;
        inputTransformationChanged: Signal<() => void>;
        closed: Signal<() => void>;
        /** Emitted whenever the Window&#x27;s screen changes. This can happen either in consequence to a screen being removed/added or if the Window&#x27;s geometry changes. */
        outputChanged: Signal<() => void>;
        skipCloseAnimationChanged: Signal<() => void>;
        /** Emitted whenever the window role of the window changes. */
        windowRoleChanged: Signal<() => void>;
        /** Emitted whenever the window class name or resource name of the window changes. */
        windowClassChanged: Signal<() => void>;
        /** Emitted whenever the Surface for this Window changes. */
        surfaceChanged: Signal<() => void>;
        /** Emitted whenever the window&#x27;s shadow changes. */
        shadowChanged: Signal<() => void>;
        /** This signal is emitted when the Window&#x27;s buffer geometry changes. */
        bufferGeometryChanged: Signal<(oldGeometry: QRectF) => void>;
        /** This signal is emitted when the Window&#x27;s frame geometry changes. */
        frameGeometryChanged: Signal<(oldGeometry: QRectF) => void>;
        /** This signal is emitted when the Window&#x27;s client geometry has changed. */
        clientGeometryChanged: Signal<(oldGeometry: QRectF) => void>;
        /** This signal is emitted when the frame geometry is about to change. The new geometry is not known yet */
        frameGeometryAboutToChange: Signal<() => void>;
        /** This signal is emitted when the visible geometry has changed. */
        visibleGeometryChanged: Signal<() => void>;
        /** This signal is emitted when associated tile has changed, including from and to none */
        tileChanged: Signal<(tile: KWin.Tile) => void>;
        requestedTileChanged: Signal<() => void>;
        fullScreenChanged: Signal<() => void>;
        skipTaskbarChanged: Signal<() => void>;
        skipPagerChanged: Signal<() => void>;
        skipSwitcherChanged: Signal<() => void>;
        iconChanged: Signal<() => void>;
        activeChanged: Signal<() => void>;
        keepAboveChanged: Signal<(param: boolean) => void>;
        keepBelowChanged: Signal<(param: boolean) => void>;
        /** Emitted whenever the demands attention state changes. */
        demandsAttentionChanged: Signal<() => void>;
        desktopsChanged: Signal<() => void>;
        activitiesChanged: Signal<() => void>;
        minimizedChanged: Signal<() => void>;
        paletteChanged: Signal<(p: QPalette) => void>;
        colorSchemeChanged: Signal<() => void>;
        captionChanged: Signal<() => void>;
        captionNormalChanged: Signal<() => void>;
        maximizedAboutToChange: Signal<(mode: MaximizeMode) => void>;
        maximizedChanged: Signal<() => void>;
        transientChanged: Signal<() => void>;
        modalChanged: Signal<() => void>;
        quickTileModeChanged: Signal<() => void>;
        moveResizedChanged: Signal<() => void>;
        moveResizeCursorChanged: Signal<(param: CursorShape) => void>;
        interactiveMoveResizeStarted: Signal<() => void>;
        interactiveMoveResizeStepped: Signal<(geometry: QRectF) => void>;
        interactiveMoveResizeFinished: Signal<() => void>;
        closeableChanged: Signal<(param: boolean) => void>;
        minimizeableChanged: Signal<(param: boolean) => void>;
        maximizeableChanged: Signal<(param: boolean) => void>;
        desktopFileNameChanged: Signal<() => void>;
        applicationMenuChanged: Signal<() => void>;
        hasApplicationMenuChanged: Signal<(param: boolean) => void>;
        applicationMenuActiveChanged: Signal<(param: boolean) => void>;
        unresponsiveChanged: Signal<(param: boolean) => void>;
        decorationChanged: Signal<() => void>;
        hiddenChanged: Signal<() => void>;
        hiddenByShowDesktopChanged: Signal<() => void>;
        lockScreenOverlayChanged: Signal<() => void>;
        readyForPaintingChanged: Signal<() => void>;
        maximizeGeometryRestoreChanged: Signal<() => void>;
        fullscreenGeometryRestoreChanged: Signal<() => void>;
        offscreenRenderingChanged: Signal<() => void>;
        targetScaleChanged: Signal<() => void>;
        nextTargetScaleChanged: Signal<() => void>;
        noBorderChanged: Signal<() => void>;
        tagChanged: Signal<() => void>;
        descriptionChanged: Signal<() => void>;
        borderRadiusChanged: Signal<() => void>;
    }

    class CustomTile extends KWin.Tile {
        /** Properties */
        layoutDirection: KWin.Tile.LayoutDirection;

        relativeGeometry: QRectF;

        absoluteGeometry: QRectF;

        absoluteGeometryInScreen: QRectF;

        padding: number;

        minimumSize: QSizeF;

        positionInLayout: number;

        parent: Tile;

        tiles: KWin.Tile[];

        windows: KWin.Window[];

        isLayout: boolean;

        canBeRemoved: boolean;

        constructor();

        /** Qt Decorated Methods */
        /**
         * move a floating tile by an amount of pixels. not supported on horizontal and vertical layouts
         * @Q_INVOKABLE
         */
        moveByPixels(delta: QPointF): void;
        /** @Q_INVOKABLE  */
        remove(): void;
        /**
         * Splits the current tile, either creating two children or a new sibling
         * @Q_INVOKABLE
         */
        split(newDirection: KWin.Tile.LayoutDirection): CustomTile[];
        /** @Q_INVOKABLE  */
        resizeByPixels(delta: number, edge: Qt.Edge): void;
        /** @Q_INVOKABLE  */
        manage(window: Window): boolean;
        /** @Q_INVOKABLE  */
        unmanage(window: Window): boolean;

        /** Signals */
        layoutDirectionChanged: Signal<(direction: Tile.LayoutDirection) => void>;
        layoutModified: Signal<() => void>;
        activeChanged: Signal<(active: boolean) => void>;
        relativeGeometryChanged: Signal<() => void>;
        absoluteGeometryChanged: Signal<() => void>;
        windowGeometryChanged: Signal<() => void>;
        paddingChanged: Signal<(padding: number) => void>;
        minimumSizeChanged: Signal<(size: QSizeF) => void>;
        rowChanged: Signal<(row: number) => void>;
        isLayoutChanged: Signal<(isLayout: boolean) => void>;
        childTilesChanged: Signal<() => void>;
        windowAdded: Signal<(window: Window) => void>;
        windowRemoved: Signal<(window: Window) => void>;
        windowsChanged: Signal<() => void>;
    }

    class OutputChangeSet {
        constructor();
    }

    class TileModel {
        constructor();
    }

    class CursorShape {
        constructor();
    }

    class Options {
        /** Properties */
        focusPolicy: KWin.Options.ActivationDesktopPolicy;

        xwaylandCrashPolicy: XwaylandCrashPolicy;

        xwaylandMaxCrashCount: number;

        nextFocusPrefersMouse: boolean;

        /** Whether clicking on a window raises it in FocusFollowsMouse mode or not. */
        clickRaise: boolean;

        /** Whether autoraise is enabled FocusFollowsMouse mode or not. */
        autoRaise: boolean;

        /** Autoraise interval. */
        autoRaiseInterval: number;

        /** Delayed focus interval. */
        delayFocusInterval: number;

        /** Whether to see Xinerama screens separately for focus (in Alt+Tab, when activating next client) */
        separateScreenFocus: boolean;

        placement: PlacementPolicy;

        activationDesktopPolicy: KWin.Options.ActivationDesktopPolicy;

        readonly focusPolicyIsReasonable: boolean;

        /** The size of the zone that triggers snapping on desktop borders. */
        borderSnapZone: number;

        /** The size of the zone that triggers snapping with other windows. */
        windowSnapZone: number;

        /** The size of the zone that triggers snapping on the screen center. */
        centerSnapZone: number;

        /** Snap only when windows will overlap. */
        snapOnlyWhenOverlapping: boolean;

        /** The size of the virtual barrier at edges between screens. */
        edgeBarrier: number;

        /** Whether to enable a cursor barrier at the corners of the screen. */
        cornerBarrier: number;

        /** Whether or not we roll over to the other edge when switching desktops past the edge. */
        rollOverDesktops: boolean;

        /** 0 - 4 , see Workspace::allowWindowActivation() */
        focusStealingPreventionLevel: number;

        operationTitlebarDblClick: KWin.Options.ActivationDesktopPolicy;

        operationMaxButtonLeftClick: KWin.Options.ActivationDesktopPolicy;

        operationMaxButtonMiddleClick: KWin.Options.ActivationDesktopPolicy;

        operationMaxButtonRightClick: KWin.Options.ActivationDesktopPolicy;

        commandActiveTitlebar1: KWin.Options.ActivationDesktopPolicy;

        commandActiveTitlebar2: KWin.Options.ActivationDesktopPolicy;

        commandActiveTitlebar3: KWin.Options.ActivationDesktopPolicy;

        commandInactiveTitlebar1: KWin.Options.ActivationDesktopPolicy;

        commandInactiveTitlebar2: KWin.Options.ActivationDesktopPolicy;

        commandInactiveTitlebar3: KWin.Options.ActivationDesktopPolicy;

        commandWindow1: KWin.Options.ActivationDesktopPolicy;

        commandWindow2: KWin.Options.ActivationDesktopPolicy;

        commandWindow3: KWin.Options.ActivationDesktopPolicy;

        commandWindowWheel: KWin.Options.ActivationDesktopPolicy;

        commandAll1: KWin.Options.ActivationDesktopPolicy;

        commandAll2: KWin.Options.ActivationDesktopPolicy;

        commandAll3: KWin.Options.ActivationDesktopPolicy;

        keyCmdAllModKey: number;

        doubleClickBorderToMaximize: boolean;

        /** Whether the visible name should be condensed. */
        condensedTitle: boolean;

        /** Whether a window gets maximized when it reaches top screen edge while being moved. */
        electricBorderMaximize: boolean;

        /** Whether a window is tiled to half screen when reaching left or right screen edge while been moved. */
        electricBorderTiling: boolean;

        /** Whether a window is tiled to half screen when reaching left or right screen edge while been moved. */
        electricBorderCornerRatio: number;

        borderlessMaximizedWindows: boolean;

        /** timeout before non-responding application will be killed after attempt to close. */
        killPingTimeout: number;

        compositingMode: number;

        /** 0 &#x3D; no, 1 &#x3D; yes when transformed, 2 &#x3D; try trilinear when transformed; else 1, -1 &#x3D; auto */
        allowTearing: boolean;

        interactiveWindowMoveEnabled: boolean;

        constructor();

        /** Signals */
        focusPolicyChanged: Signal<() => void>;
        focusPolicyIsResonableChanged: Signal<() => void>;
        xwaylandCrashPolicyChanged: Signal<() => void>;
        xwaylandMaxCrashCountChanged: Signal<() => void>;
        xwaylandEavesdropsChanged: Signal<() => void>;
        xwaylandEavesdropsMouseChanged: Signal<() => void>;
        xwaylandEisNoPromptChanged: Signal<() => void>;
        nextFocusPrefersMouseChanged: Signal<() => void>;
        clickRaiseChanged: Signal<() => void>;
        autoRaiseChanged: Signal<() => void>;
        autoRaiseIntervalChanged: Signal<() => void>;
        delayFocusIntervalChanged: Signal<() => void>;
        separateScreenFocusChanged: Signal<(param: boolean) => void>;
        placementChanged: Signal<() => void>;
        activationDesktopPolicyChanged: Signal<() => void>;
        borderSnapZoneChanged: Signal<() => void>;
        windowSnapZoneChanged: Signal<() => void>;
        centerSnapZoneChanged: Signal<() => void>;
        snapOnlyWhenOverlappingChanged: Signal<() => void>;
        edgeBarrierChanged: Signal<() => void>;
        cornerBarrierChanged: Signal<() => void>;
        rollOverDesktopsChanged: Signal<(enabled: boolean) => void>;
        focusStealingPreventionLevelChanged: Signal<() => void>;
        operationTitlebarDblClickChanged: Signal<() => void>;
        operationMaxButtonLeftClickChanged: Signal<() => void>;
        operationMaxButtonRightClickChanged: Signal<() => void>;
        operationMaxButtonMiddleClickChanged: Signal<() => void>;
        commandActiveTitlebar1Changed: Signal<() => void>;
        commandActiveTitlebar2Changed: Signal<() => void>;
        commandActiveTitlebar3Changed: Signal<() => void>;
        commandInactiveTitlebar1Changed: Signal<() => void>;
        commandInactiveTitlebar2Changed: Signal<() => void>;
        commandInactiveTitlebar3Changed: Signal<() => void>;
        commandWindow1Changed: Signal<() => void>;
        commandWindow2Changed: Signal<() => void>;
        commandWindow3Changed: Signal<() => void>;
        commandWindowWheelChanged: Signal<() => void>;
        commandAll1Changed: Signal<() => void>;
        commandAll2Changed: Signal<() => void>;
        commandAll3Changed: Signal<() => void>;
        keyCmdAllModKeyChanged: Signal<() => void>;
        doubleClickBorderToMaximizeChanged: Signal<() => void>;
        condensedTitleChanged: Signal<() => void>;
        electricBorderMaximizeChanged: Signal<() => void>;
        electricBorderTilingChanged: Signal<() => void>;
        electricBorderCornerRatioChanged: Signal<() => void>;
        borderlessMaximizedWindowsChanged: Signal<() => void>;
        killPingTimeoutChanged: Signal<() => void>;
        compositingModeChanged: Signal<() => void>;
        animationSpeedChanged: Signal<() => void>;
        configChanged: Signal<() => void>;
        allowTearingChanged: Signal<() => void>;
        interactiveWindowMoveEnabledChanged: Signal<() => void>;
    }
}

// Global properties and methods available in KWin scripts.

/**
 * Global property to all configuration values of KWin core.
 */
declare const options: KWin.Options;

/**
 * Global property to the core wrapper of KWin.
 */
declare const workspace: KWin.WorkspaceWrapper;

/**
 * Prints all provided values to kDebug and as a D-Bus signal.
 */
declare function print(...values: QVariant[]): void;

/**
 * Reads the config value for key in the Script's configuration with the optional default value.
 * If not providing a default value and no value stored in the configuration an undefined value is returned.
 */
declare function readConfig(key: string, defaultValue?: QVariant): QVariant;

/**
 * Registers the callback for the screen edge. When the mouse gets pushed against the given edge the callback will be invoked.
 */
declare function registerScreenEdge(border: KWin.ElectricBorder, callback: QScriptValue): boolean;

/**
 * Unregisters the callback for the screen edge.
 */
declare function unregisterScreenEdge(border: KWin.ElectricBorder): boolean;

/**
 * Registers keySequence as a global shortcut.
 * When the shortcut is invoked the callback will be called. Title and text are used to name the shortcut and make it available to the global shortcut configuration module.
 */
declare function registerShortcut(
    title: string,
    text: string,
    keySequence: string,
    callback: QScriptValue,
): boolean;

/**
 * Aborts the execution of the script if value does not evaluate to true.
 * If message is provided an error is thrown with the given message, if not provided an error with default message is thrown.
 */
declare function assert(value: boolean, message?: string): boolean;

/**
 * Aborts the execution of the script if value does not evaluate to true.
 * If message is provided an error is thrown with the given message, if not provided an error with default message is thrown.
 */
declare function assertTrue(value: boolean, message?: string): boolean;

/**
 * Aborts the execution of the script if value does not evaluate to false.
 * If message is provided an error is thrown with the given message, if not provided an error with default message is thrown.
 */
declare function assertFalse(value: boolean, message?: string): boolean;

/**
 * Aborts the execution of the script if the actual value is not equal to the expected value.
 * If message is provided an error is thrown with the given message, if not provided an error with default message is thrown.
 */
declare function assertEquals(expected: QVariant, actual: QVariant, message?: string): boolean;

/**
 * Aborts the execution of the script if value is not null.
 * If message is provided an error is thrown with the given message, if not provided an error with default message is thrown.
 */
declare function assertNull(value: QVariant, message?: string): boolean;

/**
 * Aborts the execution of the script if value is null.
 * If message is provided an error is thrown with the given message, if not provided an error with default message is thrown.
 */
declare function assertNotNull(value: QVariant, message?: string): boolean;

/**
 * Call a D-Bus method at (service, path, interface and method). A variable number of arguments can be added.
 * The D-Bus call is always performed in an async way invoking the callback provided as the last (optional) argument.
 * The reply values of the D-Bus method call are passed to the callback.
 */
declare function callDBus(
    service: string,
    path: string,
    interfaceName: string,
    method: string,
    ...args: (QVariant | QScriptValue)[]
): void;

/**
 * Registers the passed in callback to be invoked whenever the User actions menu (Alt+F3 or right click on window decoration) is about to be shown.
 * The callback is invoked with a reference to the Client for which the menu is shown.
 */
declare function registerUserActionsMenu(callback: QScriptValue): void;
